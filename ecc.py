from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes , padding
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes  # Add this import
import os

# Generate ECC key pair for the recipient
private_key = ec.generate_private_key(ec.SECP256R1(), default_backend())
public_key = private_key.public_key()

# Serialize the recipient's public key
public_key_bytes = public_key.public_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PublicFormat.SubjectPublicKeyInfo
)

# Serialize and save the recipient's private key
recipient_private_key_bytes = private_key.private_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PrivateFormat.PKCS8,
    encryption_algorithm=serialization.NoEncryption()
)
with open("recipient_private_key.pem", "wb") as f:
    f.write(recipient_private_key_bytes)

# Assume 'chaotic_key' is your chaotic key generated by 'kg.keygen()'
chaotic_key = str([0.01,4,256,256])

# Derive a shared secret using ECDH key agreement
shared_secret = private_key.exchange(ec.ECDH(), public_key)

# Derive a symmetric encryption key from the shared secret
hkdf = HKDF(
    algorithm=hashes.SHA256(),
    length=32,  # Length of the symmetric key (AES-256)
    salt=None,  # Salt
    info=b'encryption key',  # Context for key derivation
    backend=default_backend()
)
symmetric_key = hkdf.derive(shared_secret)

# Encrypt the chaotic key using AES encryption with the derived key
cipher = Cipher(algorithms.AES(symmetric_key), modes.ECB(), backend=default_backend())
encryptor = cipher.encryptor()

# Pad the data to the appropriate block size
padder = padding.PKCS7(128).padder()
padded_data = padder.update(chaotic_key.encode()) + padder.finalize()

# Encrypt the padded data
encrypted_key = encryptor.update(padded_data) + encryptor.finalize()


# Serialize and save the encrypted key
with open("encrypted_key.bin", "wb") as f:
    f.write(encrypted_key)

# Save the recipient's public key (for decryption)
with open("recipient_public_key.pem", "wb") as f:
    f.write(public_key_bytes)

